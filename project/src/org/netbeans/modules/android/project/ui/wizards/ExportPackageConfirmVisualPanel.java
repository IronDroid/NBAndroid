/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.netbeans.modules.android.project.ui.wizards;

import com.google.common.base.Preconditions;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStore.PrivateKeyEntry;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.UnrecoverableEntryException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Calendar;
import org.netbeans.modules.android.project.ui.customizer.AndroidProjectProperties;
import org.openide.WizardDescriptor;

public final class ExportPackageConfirmVisualPanel extends SettingsPanel {

  private String errorMsg = null;
  private Exception exc;
  private boolean valid = true;
  private final ExportPackageConfirmWizardPanel wizPanel;

  /** Creates new form ExportPackageVisualPanel2 */
  public ExportPackageConfirmVisualPanel(ExportPackageConfirmWizardPanel wizPanel) {
    this.wizPanel = Preconditions.checkNotNull(wizPanel);
    initComponents();
  }

  @Override
  public String getName() {
    return "Summary";
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jLabelOutput = new javax.swing.JLabel();
    jTextFieldOutput = new javax.swing.JTextField();
    jLabelText = new javax.swing.JLabel();

    org.openide.awt.Mnemonics.setLocalizedText(jLabelOutput, org.openide.util.NbBundle.getMessage(ExportPackageConfirmVisualPanel.class, "ExportPackageConfirmVisualPanel.jLabelOutput.text")); // NOI18N

    jTextFieldOutput.setEditable(false);
    jTextFieldOutput.setText(org.openide.util.NbBundle.getMessage(ExportPackageConfirmVisualPanel.class, "ExportPackageConfirmVisualPanel.jTextFieldOutput.text")); // NOI18N

    org.openide.awt.Mnemonics.setLocalizedText(jLabelText, org.openide.util.NbBundle.getMessage(ExportPackageConfirmVisualPanel.class, "ExportPackageConfirmVisualPanel.jLabelText.text")); // NOI18N

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(jLabelText, javax.swing.GroupLayout.DEFAULT_SIZE, 376, Short.MAX_VALUE)
          .addGroup(layout.createSequentialGroup()
            .addComponent(jLabelOutput)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(jTextFieldOutput, javax.swing.GroupLayout.DEFAULT_SIZE, 281, Short.MAX_VALUE)))
        .addContainerGap())
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabelOutput)
          .addComponent(jTextFieldOutput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
        .addComponent(jLabelText, javax.swing.GroupLayout.DEFAULT_SIZE, 236, Short.MAX_VALUE)
        .addContainerGap())
    );
  }// </editor-fold>//GEN-END:initComponents

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JLabel jLabelOutput;
  private javax.swing.JLabel jLabelText;
  private javax.swing.JTextField jTextFieldOutput;
  // End of variables declaration//GEN-END:variables

  @Override
  void store(WizardDescriptor settings) {
    // nothing to store in this step
    // privateKey and certificate can be stored but Ant will compute them again
  }

  @Override
  void read(WizardDescriptor settings) {
    exc = null;
    PrivateKey privateKey = null;
    X509Certificate certificate = null;
    String details = "";
    String releaseFileName = (String) settings.getProperty(
        AndroidProjectProperties.PROP_RELEASE_FILE);
    jTextFieldOutput.setText(releaseFileName);

    Boolean useAlias = (Boolean) settings.getProperty(
        ExportPackageWizardIterator.PROP_USE_EXISTING_ALIAS);
    Boolean useKeystore = (Boolean) settings.getProperty(
        ExportPackageWizardIterator.PROP_USE_EXISTING_KEYSTORE);
    if (!useKeystore || !useAlias) {
        int validity = (Integer) settings.getProperty(
            ExportPackageWizardIterator.PROP_KEY_ALIAS_VALIDITY);
        StringBuilder sb = new StringBuilder(
                String.format("<p>Certificate expires in %d years.</p>",
                validity));

        if (validity < 25) {
            sb.append("<p>Make sure the certificate is valid for the planned lifetime of the product.</p>");
            sb.append("<p>If the certificate expires, you will be forced to sign your application with a different one.</p>");
            sb.append("<p>Applications cannot be upgraded if their certificate changes from one version to another, ");
            sb.append("forcing a full uninstall/install, which will make the user lose his/her data.</p>");
            sb.append("<p>Android Market currently requires certificates to be valid until 2033.</p>");
        }

        details = sb.toString();
    } else {
      try {
        String keystore = (String) settings.getProperty(AndroidProjectProperties.PROP_KEY_STORE);
        String keystorePasswd = 
            (String) settings.getProperty(AndroidProjectProperties.PROP_KEY_STORE_PASSWD);
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        FileInputStream fis = new FileInputStream(keystore);
        keyStore.load(fis, keystorePasswd.toCharArray());
        fis.close();

        PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(
                (String) settings.getProperty(AndroidProjectProperties.PROP_KEY_ALIAS),
                new KeyStore.PasswordProtection(
                        ((String) settings.getProperty(AndroidProjectProperties.PROP_KEY_ALIAS_PASSWD)).toCharArray()));

        if (entry != null) {
            privateKey = entry.getPrivateKey();
            certificate = (X509Certificate)entry.getCertificate();
        } else {
            errorMsg = "Unable to find key.";
        }
      } catch (KeyStoreException e) {
        onException(e);
      } catch (NoSuchAlgorithmException e) {
        onException(e);
      } catch (UnrecoverableEntryException e) {
        onException(e);
      } catch (CertificateException e) {
        onException(e);
      } catch (IOException e) {
        onException(e);
      }

      if (privateKey != null && certificate != null) {
          Calendar expirationCalendar = Calendar.getInstance();
          expirationCalendar.setTime(certificate.getNotAfter());
          Calendar today = Calendar.getInstance();

          if (expirationCalendar.before(today)) {
            details = String.format(
                    "<p>Certificate expired on %s</p>",
                    certificate.getNotAfter().toString());

            errorMsg = "Certificate is expired.";
          } else {
            StringBuilder sb = new StringBuilder(String.format(
                    "<p>Certificate expires on %s.</p>",
                    certificate.getNotAfter().toString()));

            int expirationYear = expirationCalendar.get(Calendar.YEAR);
            int thisYear = today.get(Calendar.YEAR);

            if (thisYear + 25 < expirationYear) {
                // do nothing
            } else {
              if (expirationYear == thisYear) {
                sb.append("<p>The certificate expires this year.</p>");
              } else {
                int count = expirationYear-thisYear;
                sb.append(String.format(
                        "<p>The Certificate expires in %1$s %2$s.</p>",
                        count, count == 1 ? "year" : "years"));
              }

              sb.append("<p>Make sure the certificate is valid for the planned lifetime of the product.</p>");
              sb.append("<p>If the certificate expires, you will be forced to sign your application with a different one.</p>");
              sb.append("<p>Applications cannot be upgraded if their certificate changes from one version to another, ");
              sb.append("forcing a full uninstall/install, which will make the user lose his/her data.</p>");
              sb.append("<p>Android Market currently requires certificates to be valid until 2033.</p>");
            }

            details = sb.toString();
          }
      } else {
          // fatal error = nothing can make the page complete.
          errorMsg = "There is some problem with certificate";
      }
    }
    jLabelText.setText("<html>" + details);
  }

  private void onUpdate() {
    wizPanel.onChange();
  }

  @Override
  boolean valid(WizardDescriptor settings) {
    settings.putProperty("WizardPanel_errorMessage", !valid ? errorMsg : null);
    return this.valid;
  }

  @Override
  void validate(WizardDescriptor settings) {
    valid = false;

    if (exc != null) {
      errorMsg = exc.getLocalizedMessage();
      return;
    }
    valid = true;
  }

  private void onException(Exception ex) {
    valid = false;
    errorMsg = ex.getLocalizedMessage();
    exc = ex;
    onUpdate();
  }

  boolean isFinishable() {
    return valid;
  }
}
